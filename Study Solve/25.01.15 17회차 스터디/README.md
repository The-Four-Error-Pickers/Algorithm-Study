# 지난 스터디(01.09) 회고

전원 구현 완료

# 선정 문제

<b> 프로그래머스 Lv3. 블록 이동하기</b>
<br>
<b> [문제 링크](https://school.programmers.co.kr/learn/courses/30/lessons/60063) </b>

# 문제 출제 및 서기

<b> 정현(Be-HinD) </b>

# 20분 결과

<p> 정현 : 접근 </p>
<p> 회창 : 접근 </p>
<p> 준호 : 접근 </p>
<p> 승현 : 접근 </p>
<p> 찬혁 : 접근 </p>

# 토론내용 정리

### 유형

<P> BFS </P>

### 시간복잡도

<p> O(N^4) </p>

가능한 모든 상태의 수 -> (x1,y1) = N^2 * (x2,y2) = N^2 == N^4 

### 접근법

> 정현

<b> 다익스트라 </b>

<p> 방문 체크 : visited[x1+y1+x2+y2][수평/수직]에 대한 2차원 배열 </p>
<p> 회전 로직 : 한칸은 고정, 나머지 칸에 대해 이동 해야 하는 2칸에 대해 벽,범위 체크 </p>
<p> 다익스트라 정렬 기준 : 이동한 값 </p>

> 회창

<b> BFS </b>

<p> 8방향 이동 가능 여부 체크 : 시뮬레이션 </p>
<p> 방문 체크 : 3차원 배열 -> 한 개의 좌표(x1, y1)와 방향(수평/수직) </p>

> 준호

<b> BFS </b>

<p> 방문 체크 : 백준 벽 부수고 이동하기 문제에서 참고 -> 벽 부순 횟수 대신 방향에 대해 방문체크 </p>
<p> + 3차원 배열 : 위와 동일 </p>

> 승현

<b> BFS </b>

<p> 방문 체크 : 두 개의 좌표 -> String Combine -> Set을 통해 확인 </p>
<p> 현재 좌표 : head/tail 두 개의 좌표 </p>
<p> 회전 로직 : 두 개의 좌표 기준, 위 두칸 및 아래 두칸에 대해 이동 가능 여부 확인 </p>

> 찬혁

<b> BFS </b>

<p> 방문 체크 : [N][N][4] -> 한 개의 좌표를 기준으로 나머지 좌표의 방향을 저장 </p>
<p> [0][0][왼쪽], [0][1][오른쪽]처럼 하나의 형태에 대해 2가지를 확인 </p>

> 토론 포인트

<p> 완전탐색을 기반으로 "방문 체크를 어떻게 할 것인지"와 "회전 로직을 어떻게 해야 효율적?"의 두 가지 토론 포인트가 있었음. </p>

> 좋았던 의견

<p> 범위 체크의 편리함 : board의 외곽을 추가&벽(1)으로 처리하여 별도의 범위 체크를 하지 않을 수 있음. </p>
<p> 방문 체크 : 두 개의 좌표 각각을 수평/수직에 따라 방문체크를 하게되면 3차원 배열로 풀이 가능. </p>

# 풀이 링크

<a href="https://github.com/The-Four-Error-Pickers/Algorithm-Study/tree/main/Private%20Solve/프로그래머스/60063.%20%EB%B8%94%EB%A1%9D%20%EC%9D%B4%EB%8F%99%ED%95%98%EA%B8%B0">링크</a>
