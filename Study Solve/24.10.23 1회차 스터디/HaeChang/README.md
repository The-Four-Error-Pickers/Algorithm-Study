## [프로그래머스 Lv3. 풍선 터트리기](https://school.programmers.co.kr/learn/courses/30/lessons/68646)

> 문제의 키워드

- 원소가 1_000_000 개에 모두 서로다른 숫자임, 원소값의 범위는 -10^9 ~ 10^9
- 인접한 두 수에 대하여 다음의 연산이 가능
    - 더 큰 풍선을 없애기 [계속 가능]
    - 더 작은 풍선을 없애기 [단 한번만 수행]

<br/>

> 접근법 분석

- 입력 배열 a의 길이는 1 부터 1,000,000
  - 일반적인 N^2은 안되고, dp로 O(N) 접근법을 사용하려 해도, 이전의 사용값을 재사용할 부분이 명확하지 않음
  - 내가 암만 생각해도 모르겠으면서 dp의 점화식도 뚜렷하지 않다면 <strong>그리디 문제로 판단</strong>

<br/>

> 그리디 접근법

- 그리디하게 접근하려면 결국 쿼리를 처리하는데 필요한 정곡을 찌르는 식이 필요
- 특정 인덱스의 원소가 살아남는 조건을 떠올려보자면
  - 결국 시뮬레이션 한번당 최대 한번의 작은수 삭제를 할 수 있음
  - 이말은 즉, 마지막에 자신의 왼쪽과 오른쪽에 남은 숫자가 자신보다 둘다 작은경우엔 안된다는것을 파악할 수 잇음
  - 그렇다는 것은, 더 작은 풍선을 삭제하는 연산을 한번도 사용하지 않았을 때, 최후의 양옆 값이 자신보다 모두 작은경우는 살아남을 수 없음
    - 이 때 최후의 양옆 값은, 단순하게 특정 인덱스를 제외하고 왼쪽에서부터의 더 큰 값만을 없애서 살아남은 원소와 오른쪽도 똑같이 작동시켜서 남은 값

<br/>

> 구현 접근법

- L, R 테크닉을 사용함
    - 왼쪽에서의 누적연산의 결과와 오른쪽에서의 누적연산의 결과를 파악하기에 적합한 알고리즘이기 때문에 사용

<br/>

> 시간복잡도

#### O(N)

<br/>

### 구현 코드

```java
class Solution {
    public int solution(int[] a) {
        int answer = 0;
        int[] L = new int[a.length];
        int[] R = new int[a.length];
        
        L[0] = a[0];
        R[a.length-1] = a[a.length-1];
        
        for(int i=1;i<a.length;i++) {
            L[i] = Math.min(L[i-1], a[i]);
        }
        for(int i = a.length - 2;i>-1;i--) {
            R[i] = Math.min(R[i+1], a[i]);
        }
        
        for(int i = 0;i<a.length;i++) {
            if ((i - 1 >= 0 && L[i-1] < a[i]) && (i + 1 < a.length && R[i+1] < a[i])) {
                continue;
            }    
            answer++;
        }
            
        return answer;
    }
}
```

### 제출 결과

![제출결과](./result.png)

<br>

# 토론 접근법 풀이

<p> 억수로 어려웠다. 단순히 내가 자만정 때린 방법에 의거하여 그리디인것을 추정 한 것이 전부</p>
<p> 그리디는 항상 넓고 넓은 값에 대하여, 특이한 연산을 수행하기에 특이한 정곡을 찌르는 정답이 존재한다는것을 잊으면 안됨 </p>
<p> 재귀연산처럼 너무 깊게 파고들려고 하지말자 </p>

#### 풀이 링크

[Private Solve](https://github.com/The-Four-Error-Pickers/Algorithm-Study/tree/main/Private%20Solve/68646.%20%ED%92%8D%EC%84%A0%20%ED%84%B0%ED%8A%B8%EB%A6%AC%EA%B8%B0/HaeChang/2024-10-28T123952)
