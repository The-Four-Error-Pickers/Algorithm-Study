## [프로그래머스 Lv3. 보행자 천국](https://school.programmers.co.kr/learn/courses/30/lessons/1832)

> 문제의 키워드

- 왼쪽 위의 출발점에서 오른쪽 아래 도착점까지 자동차로 이동 가능한 전체 가능한 경로 수를 출력하는 프로그램을 작성
- 가능한 경로의 수는 컴퓨터가 표현할 수 있는 정수의 범위를 넘어설 수 있으므로, 가능한 경로 수를 20170805로 나눈 나머지 값을 출력
- 출발점과 도착점의 `city_map[i][j]` 값은 0이다.
- `1 <= m, n <= 500`

<br/>

> 접근법 분석

- 경우의 수를 구하는 문제이면서, 이전의 값을 활용할 수 있으므로 DP 로 접근이 가능하다.
- 처음엔 문제에서 특정 칸에 도달할 때 직진으로 도달한 경우와 꺾어서 도달한 경우로 구분했엇다.
    - 근데 이는 잘못되었는 것이, `(1,1)` 의 경우를 생각해보면 위에서 직진으로 내려왔을 수가 없고 반드시 꺾여야 한다.
    - 이를 위해서 테두리 안의 특수 테두리를 전처리한다? 이건 좀 이상하다.

- 따라서 생각을 달리하길, 특정 칸에 아래로 도달한 경우와 왼쪽에서 온 경우로 구분했다.
    - 이러면 `(1,1)` 의 경우여도, `(0,1)`에서 도달한 경우는 반드시 위에서 회전을 해야 하고 
    - `(1,0)` 에서는 반드시 내려오다가 꺾어야 함을 명확하게 구분할 수 있다.
    - 만약 직진의 경우라면 이전과 방향이 동일해야 한다.

<br/>

> 구현 접근법

dp 배열을 3차원으로 구성하고 각각 y좌표, x좌표 그리고 왼쪽에서 오른쪽에서 온 상태를 구분하기위한 크기 2를 잡아준다.

```
0: 왼쪽에서 온 경우
1: 위에서 내려온 경우
```

윗 테두리의 경우 왼쪽에서만 올 수 있고, 왼쪽 면에 대해서는 위에서 만 올 수 있기에 전처리하고
```
윗테두리: dp[0][i][0] = (dp[0][i][0] + dp[0][i - 1][0]) % MOD;
왼쪽 면: dp[i][0][1] = (dp[i][0][1] + dp[i - 1][0][1]) % MOD;
```

나머지 (1, 1) ~ (N, M) 의 경우에서는 어떤 좌표 y, x에 대해서 다음과 같은 경우의 수 를 나눠 계산한다.

```
이전칸도 왼쪽에서 왔으면서 지금까지 쭉 직진한 경우: dp[i][j][0] = (dp[i][j][0] + dp[i][j - 1][0]) % MOD

이전칸도 위에서 왔으면서 지금까지 쭉 내려간 경우: dp[i][j][1] = (dp[i][j][1] + dp[i - 1][j][1]) % MOD;

이전칸은 왼쪽에서 왔으면서 지금칸으로 꺾어서 내려온 경우: dp[i][j][1] = (dp[i][j][1] + dp[i - 1][j][0]) % MOD;

이전칸은 위에서 왔으면서 지금칸으로 꺾어서 왼쪽에서 온 경우: dp[i][j][0] = (dp[i][j][0] + dp[i][j - 1][1]) % MOD;
```


<br/>

> 시간복잡도

#### O(N * M): city_map에 사용된 지도의 크기

<br/>

### 구현 코드

```java
class Solution {
    int MOD = 20170805;
    public int solution(int m, int n, int[][] cityMap) {
        int answer = 0;
        
        int[][][] dp = new int[m][n][2]; 
        
        
        dp[0][0][0] = 1;
        dp[0][0][1] = 1;
        
        for(int i = 1; i < n; i++) {
            if (cityMap[0][i] == 1) {
                break;
            } else {
                dp[0][i][0] = (dp[0][i][0] + dp[0][i - 1][0]) % MOD;
            }
        }
        for(int i = 1; i < m; i++) {
            if (cityMap[i][0] == 1) {
                break;
            } else {
                dp[i][0][1] = (dp[i][0][1] + dp[i - 1][0][1]) % MOD;
            }
        }
        
        for(int i = 1; i < m; i++) {
            for(int j = 1;j < n; j ++) {
                if (cityMap[i][j] != 1) {
                    // 진행 가능하면서
                    // 위에서 오고있으면서 전진경우
                    dp[i][j][1] = (dp[i][j][1] + dp[i - 1][j][1]) % MOD;
                    // 왼쪽에서 오고있으면서 전진경우
                    dp[i][j][0] = (dp[i][j][0] + dp[i][j - 1][0]) % MOD;
                    if (cityMap[i - 1][j] != 2) {
                        // 왼쪽에서 전진했엇다가 이번에 꺾은경우
                        dp[i][j][1] = (dp[i][j][1] + dp[i - 1][j][0]) % MOD;    
                    }
                    if (cityMap[i][j - 1] != 2) {
                        // 위에서 전진했엇다가 오른쪽으로 꺾은경우
                        dp[i][j][0] = (dp[i][j][0] + dp[i][j - 1][1]) % MOD;
                    }
                }
                
            }
        }
        
        return (dp[m - 1][n - 1][0] + dp[m - 1][n - 1][1]) % MOD;
    }
}
```

### 제출 결과

<img src="./result.png"/>


#### 풀이 링크

[Private Solve](https://github.com/The-Four-Error-Pickers/Algorithm-Study/tree/main/Private%20Solve/프로그래머스/1832.%20%EB%B3%B4%ED%96%89%EC%9E%90%20%EC%B2%9C%EA%B5%AD/HaeChang/2025-1-2T2147)
