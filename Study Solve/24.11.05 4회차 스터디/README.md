# 지난 스터디(11.1) 회고

모두 풀이를 마쳤으므로 생략

# 선정 문제

<b> 프로그래머스 Lv3. 등대 </b>
<br>
<b> [문제 링크](https://school.programmers.co.kr/learn/courses/30/lessons/133500) </b>

# 문제 출제 및 서기

<b> 찬혁(ChaNyeok1225) </b>

# 20분 결과

<p> 정현: 접근 및 구현</p>
<p> 찬혁: 접근 및 구현</p>
<p> 준호: 접근 </p>
<p> 회창: 접근 및 구현</p>

# 토론내용 정리

### 유형

<P> 그래프 </P>
<P> DFS </P>
<P> 위상 정렬 </P>

### 시간복잡도

<p> DFS: O(V) </p>
<p> 위상 정렬: O(V) </p>

정점의 개수: V

### 접근법

> <b>준호, 찬혁</b>

<b>위상 정렬</b>

<p>문제에서 주어진 그래프간 연결에 대해 진입 차수 in-degree를 각 등대마다 계산한다.</p>
<p>계산한 진입 차수 중에서 MAX 값을 가진 등대의 불을 켠다.</p>
<p>불을 켠 등대과 연결되어 있는 등대들의 진입 차수를 감소시키고 위 과정을 모든 진입차수가 0보다 작아질 때까지 반복한다.</p>

<b>구현 결과: 실패</b>

<p>위 처럼 푼다면 연결되어 있는 등대 중 인접한 하나의 등대만 불이 켜져있는 경우에 만족함.</p>
<p>즉, 1 - 2 - 3 - 4의 구조에서 1, 4가 켜진 등대일 경우, 2와 3 중에서 하나의 등대를 더 켜야한다는 것을 인지하지 못함.  </p>

> <b>회창</b>

<b>그리디</b>

<p>문제에서 주어진 그래프간 연결에 대해 진입 차수 in-degree를 계산한다.</p>
<p>계산한 진입 차수를 내림차순 정렬하고 0번째 인덱스부터 순차적으로 누적합을 한다.</p>
<p>누적합을 하는 과정에서 합이 정점의 개수 이상이 된다면 해당 인덱스가 답이 될 것이다.</p>

<b>구현 결과: 실패</b>

<p>반례 존재, 중복노드가 많이 있는 경우, 노드 번호를 신경쓰지않아</p>
<p>합만을 보고 더하다가 "간선으로 연결된 두 등대사이에 적어도 하나의 등대는 켜져야한다"의 조건을 만족하지 못하는 경우가 생길 수 있음.</p>

> <b>정현</b>

<b>그리디</b>

<p>그래프에서 [리프 노드] 또는 [리프 노드와 붙어있는 노드]는 문제에서 반드시 둘 중 하나는 켜야하는 조건을 가지고 있다.</p>
<p>이를 근거로 하여 [리프 노드와 붙어있는 노드]를 집합을 통해 계산하고 집합의 사이즈를 결과가 답이 될 것이다.</p>

<b>구현 결과: 실패</b>

<p>반례 존재, 1 - 2 - 3 - 4 - 5 - 6의 구조에서 3개가 켜져야하지만 [리프 노드와 붙어있는 노드]는 2개로 성립하지 않음.</p>

## 최적의 접근법 토론

<b>위상 정렬</b>

<p>정현의 접근법에서 반복문과 진입 차수 배열 in-degree을 추가하여 진입 차수가 1인 노드를 리프 노드라고 판단하고</p>
<p>해당 리프 노드와 붙어있는 노드의 불을 켠다, 그 이후 해당 노드와 연결되어 있는 노드의 진입 차수를 감소시킨 후 위의 과정을 반복하여 모든 노드의 진입 차수가 0이 될때까지 반복한다.</p>

<b>DFS</b>

<p>위의 방법에서 진입 차수를 계산하지 않고 DFS를 통해 노드의 끝까지 완전 탐색을 진행 한 후</p>
<p>자신의 다음에 존재하는 노드가 불이 꺼져있다면 불을 켜는 방법을 사용한다.</p>

# 풀이 링크

<a href="https://github.com/The-Four-Error-Pickers/Algorithm-Study/tree/main/Private%20Solve/133500.%20%EB%93%B1%EB%8C%80">링크</a>
