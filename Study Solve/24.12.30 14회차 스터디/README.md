# 지난 스터디(12.27) 회고

전원 구현 완료

# 선정 문제

<b> 프로그래머스 Lv3. 표 편집</b>
<br>
<b> [문제 링크](https://school.programmers.co.kr/learn/courses/30/lessons/81303?language=java) </b>

# 문제 출제 및 서기

<b> 회창(Haechang) </b>

# 20분 결과

<p> 정현 : 접근 </p>
<p> 회창 : 접근 </p>
<p> 준호 : 접근 </p>
<p> 찬혁 : 접근 </p>

# 토론내용 정리

### 유형

<P> 자료구조, 시뮬레이션 </P>

### 시간복잡도

<p> O(SUM(X)): U와 D 명령어에 X 대해서 최대 합이 100만임</p>

### 접근법

> 준호

<b> 양방향 연결리스트, 스택 </b>

<p> 특정 원소가 삭제되는 명령어를 수행할 때, 자연스럽게 위로 땡겨지는 행위는 마치 삭제 노드의 다음노드와 이전노드를 연결하는 양방향 연결리스트 자료구조로 해석 가능 </p>
<p> 삭제시에 가장 최근에 삭제되었던 표의 칸이 먼저 복구되어야 하므로, Stack을 활용하는것이 좋음 </p>
<p> Stack 사용시 삭제된 노드의 이전노드에 대한 정보와 다음 노드에 대한 정보를 가지고 있는게 좋음 </p>

> 회창

<b> 양방향 연결리스트, 스택 </b>

<p> 위 접근법과 유사 </p>

> 찬혁

<b> 양방향 연결리스트(2차원 배열), 스택 </b>

<p> 위 접근법과 유사하나, 어짜피 값은 없으므로 2차원 배열을 활용해서 이전 노드정보와 다음 노드 정보등을 관리하여 구현하면 간단할 것으로 예상 </p>

> 정현

<b>1차원 배열</b>

<p> 삭제에 있어서 삭제된 노드를 boolean[] 으로 삭제 마킹 후, 삭제 이후노드들을 땡기는 방식 </p>
<p> 왜냐하면 위로 올라가고 아래로 내려가는 명령어 수행이 어짜피 다 합쳐도 100만이기에 하나 삭제후 땡기는 연산이 그렇게 복잡하지 않을것으로 예상함</p>

# 풀이 링크

<a href="https://github.com/The-Four-Error-Pickers/Algorithm-Study/tree/main/Private%20Solve/프로그래머스/81303.%20%ED%91%9C%20%ED%8E%B8%EC%A7%91">링크</a>
