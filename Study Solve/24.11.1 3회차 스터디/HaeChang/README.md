## [프로그래머스 Lv3. 풍선 터트리기](https://school.programmers.co.kr/learn/courses/30/lessons/68646)

> 문제의 키워드

- 자연수 n 개로 이루어진 중복집합
- 각 원소의 합이 S가 되는 수의 집합
    - 즉 집합으로 묶은 원소의 총합이 S가 되어야 한다.
- 위 조건을 만족하면서 각 원소의 곱이 최대가되는
    - 즉, 원소의 총합은 S이면서 그러한 집합들 중 최대값인 중복집합을 구해야 한다.

<br/>

> 접근법 분석

- n의 개수가 1 ~ 10000개이므로, n 개의 원소로 합이 s인 모든 중복집합을 구하려면 최악의 경우 n^10000 이 된다.
- 따라서 실제로 모든 원소를 다 대입하는 브루트포스는 안됨
- 주어진 예제를 분석해보면 다음의 결과가 나옴
    - 합이 S이며 N개의 원소로 분할한다는 것은, 다시말해 자연수 S를 N개의 자연수로 분할한단 의미
    - 추가적으로 곱이 가장크기 위해서는 가장 큰 숫자를 더해야 한단것, 즉 N개로 표현가능한 분할된 가장 큰 자연수를 사용해야 함
        - 그럴려면 최소한 몇개까지 몫으로 분할이 가능한지를 먼저 잡아야함
    - 예를들어 S = 9이고 N이 4이면
        - 9 / 4는 2이므로 나머지가 0인 8을 생각하면 2 2 2 2 이고 여기서 1을 어디에든지 더하면 된다.

    - 결국, 나머지를 균등하게 분배하는것이 중요하고, 몇개의 분할된 자연수에게 분배해야 하는지는 나머지 값에 따라 달라진다.

<br/>

> 수학적 접근법

- 위의 접근에 따라 공식은 다음과 같다.
    - 균등 분할을 위한 최솟값은 `s / n` 이며, 개수로는 `n - (s % n)`이된다.
    - 나머지 n개까지는 `s / n + 1`의 값을 가지면 된다.

<br/>

> 구현 접근법

- 결과배열은 언제나 n개의 자연수로 분할된 집합이기에 n 크기에 int 자료형 배열을 준비한다.
- 어짜피 균등분할에 최솟값을 먼저 채우면 되기에 반복문을 통해 `n - (s % n)` 개를 `s / n`으로 채우고
- 나머지 값을 분배받을 구간은 `n - (s % n)` 번째 부터 `n - 1` 번째 까지 `s / n + 1`로 채우면 된다.

<br/>

> 시간복잡도

#### O(n)

<br/>

### 구현 코드

```java
class Solution {
    public int[] solution(int n, int s) {
        if (n > s) return new int[]{-1};
        int[] answer = new int[n];
        int idx = 0; 
        int mock = s / n;
        for(int i = 0;i<n - (s % n);i++){
            answer[i] = (s / n);
        }
        for(int i = n - (s % n);i < n;i++) {
            answer[i] = (s / n) + 1;
        }
        return answer;
    }
}
```

### 제출 결과

![제출결과](./result.png)

<br>

# 토론 접근법 풀이

<p></p>

#### 풀이 링크

[Private Solve](https://github.com/The-Four-Error-Pickers/Algorithm-Study/tree/main/Private%20Solve/12938.%20%EC%B5%9C%EA%B3%A0%EC%9D%98%20%EC%A7%91%ED%95%A9/HaeChang)
