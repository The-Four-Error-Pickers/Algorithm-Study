# 지난 스터디(10.23) 회고

왼쪽에서의 누적합 필요없었다.

각 양쪽 끝에서부터 최솟값 변화가 발생하는지가 중요하기 때문에 

`HashSet` 을 통해 구현하면 `size`가 정답이 된다.

# 선정 문제
<b> 프로그래머스 Lv3. 부대복귀 </b>
<br>
<b> [문제 링크](https://school.programmers.co.kr/learn/courses/30/lessons/132266) </b>

# 문제 출제 및 서기
<b> 회창(HaeChang) </b>

# 20분 결과
<p> 정현 : 접근 및 풀이 </p>
<p> 찬혁 : 접근 및 풀이 </p>
<p> 준호 : 결근 </p>
<p> 회창 : 접근 및 풀이 </p>

# 토론내용 정리
### 유형
<P> 그래프, 다익스트라, BFS </P>

### 자료구조
<P> 우선순위 큐, 큐, 그래프 </P>

### 시간복잡도
<p> 다익스트라: O(ElogE) </p>
<p> BFS: O(VE)</p>

### 접근법

<b>회창:</b>

<b>다익스트라</b>

<p>강철 부대는 특정노드에 있고<p>
<p>각각의 강철부대원들은 유일한 번호로 되어있다. 이말인 즉, 각 부대원들이 같은 노드에 있지 않다라는 얘기</p>
<p>각 지역들이 있고 지역들을 잇는 길이 있다. 길을 통과하는 데 걸리는 시간은 1이다. 길은 왕복이 가능하다.</p>
<p>위의 말은 즉, 지역은 노드고 지역들을 잇는 길은 간선이며, 간선은 양방향이고 가중치가 1이라는 뜻</p>
<p>문제에서는 각 부대원들이 존재하는 노드번호로 부터 강철부대가 있는 노드번호 까지의 최단거리를 구하라는 거 였지만</p>
<p>결국 양방향 그래프이기 때문에 최단거리는 다익스트라를 통해 강철 부대로부터 각 노드까지로 구하면 된다.</p>
<p>그러면 부대원들이 존재하는 노드까지 최단거리가 나오기 때문에 answer 배열을 만들고 리턴하면 된다.</p>


<b>찬혁: </b>

<b>Depth 관리 BFS</b>

<p>무방향 그래프이며 간선의 가중치가 모두 동일하고 강철부대로부터 부대원들이 위치한 노드까지 최단거리를 구하라는 문제<p>
<p>다익스트라를 사용해서 풀어도 되나, 간선의 가중치가 모두 동일하기에 BFS 로도 풀린다.</p>
<p>약간의 테크닉을 사용한다면, BFS시에 어짜피 depth를 측정하는것이 곧 거리가 되기 때문에</p>
<p>Queue에 size를 측정하여 size만큼만 돌리는 depth 관리 BFS를 통해서도 효율적인 메모리관리를 할 수 있다.</p>

<b>정현: </b>

<b>다익스트라</b>

<p>처음에 sources 배열만큼 다익스트라를 돌리니까 시간초과를 맞이했다.</p>
<p>그래서 사고방식을 강철부대로 부터 모든 부대원들의 노드로 최단거리를 구하잔 것으로 바꾸었고, 최단거리를 구하는데 사용한 알고리즘은 다익스트라를 사용함</p>

# 풀이 링크

<a href="https://github.com/The-Four-Error-Pickers/Algorithm-Study/tree/main/Private%20Solve/132266.%20%EB%B6%80%EB%8C%80%EB%B3%B5%EA%B7%80">링크</a>